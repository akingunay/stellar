/*
 * generated by Xtext 2.10.0
 */
package uk.ac.lancaster.odin.lang.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.lancaster.odin.lang.bSPL.MessageReference
import uk.ac.lancaster.odin.lang.bSPL.Role
import uk.ac.lancaster.odin.lang.bSPL.Protocol
import java.util.LinkedList
import java.util.HashMap
import java.util.HashSet
import uk.ac.lancaster.odin.lang.bSPL.Parameter

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BSPLGenerator extends AbstractGenerator {

	val generatedPackagePath = "uk/ac/lancaster/turtles/stellar/gen";
	val generatedPackage = "uk.ac.lancaster.turtles.stellar.gen";
	val libraryPackage = "uk.ac.lancaster.turtles.stellar";

	// TODO test cases
	// - if there is a single message, the receiver sender's adapter does not have a getRetrievedX method and hence we do not need some included pacakages

	// TODO case sensitivity
	// TODO handling of sub protocols
	// TODO message classes should be generated for roles that are either sender or receiver of the message, not for all roles in the protoocol
	// TODO a role adapter should involve message related methods only for the messages which involve the role, not all messages in the protocol
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// TODO is there a better way to get the protocolName
		var protocolName = "";
		for (protocol : resource.allContents.toIterable.filter(Protocol)) {
			protocolName = protocol.name.toFirstUpper;
		}
		fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstLower + "/" + protocolName.toFirstUpper + ".java", resource.compileBSPLProtocolSchemaInstance(protocolName));
		for (role : resource.allContents.toIterable.filter(Role)) {

			fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstLower + "/" + role.name.toFirstLower + "/" + role.name.toFirstUpper + "Adapter.java", resource.compileAdapter(protocolName, role.name));
			for (msgRef : resource.allContents.toIterable.filter(MessageReference)) {
				if (msgRef.sender.name.equals(role.name)) {
					fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstLower + "/" + role.name.toFirstLower + "/" + msgRef.name.toFirstUpper + ".java", msgRef.compileAsSender(protocolName, role.name))
				} else {
					fsa.generateFile(generatedPackagePath + "/" + protocolName.toFirstLower + "/" + role.name.toFirstLower + "/" + msgRef.name.toFirstUpper + ".java", msgRef.compileAsReceiver(protocolName))
				}
			}
		}
	}

	def compileBSPLProtocolSchemaInstance(Resource resource, String protocolName) {
		val parametersOfProtocol = new HashSet<String>()
		val localParametersOfProtocol = new HashSet<String>()
		val keyParametersOfProtocol = new HashSet<String>()
		val inParametersOfProtocol = new HashSet<String>()
		val outParametersOfProtocol = new HashSet<String>()
		val nilParametersOfProtocol = new HashSet<String>()
		val rolesOfProtocol = new HashSet<String>()
		val messageNamesOfProtocol = new HashSet<String>()
		val senderRoleOfMessage = new HashMap<String, String>()
		val receiverRoleOfMessage = new HashMap<String, String>()
		val parametersOfMessage = new HashMap<String, HashSet<String>>()
		val keyParametersOfMessage = new HashMap<String, HashSet<String>>()
		val inParametersOfMessage = new HashMap<String, HashSet<String>>()
		val outParametersOfMessage = new HashMap<String, HashSet<String>>()
		val nilParametersOfMessage = new HashMap<String, HashSet<String>>()
		
		for (role : resource.allContents.toIterable.filter(Role)) {
			rolesOfProtocol.add(role.name)
		}
		
		for (parameter : resource.allContents.toIterable.filter(Parameter)) {
			parametersOfProtocol.add(parameter.name)
			if (parameter.key) {
				keyParametersOfProtocol.add(parameter.name)
			}
			if (parameter.adornment.equals("in")) {
				inParametersOfProtocol.add(parameter.name)
			} else if (parameter.adornment.equals("out")) {
				outParametersOfProtocol.add(parameter.name)
			} else if (parameter.adornment.equals("nil")) {
				nilParametersOfProtocol.add(parameter.name)
			} else {
				// TODO since adornment is optional, we may reach here, 
				//		though I do not know what should I do with such a 
				//		parameter				
			}
		}
		
		for (msgRef : resource.allContents.toIterable.filter(MessageReference)) {
			messageNamesOfProtocol.add(msgRef.name)
			senderRoleOfMessage.put(msgRef.name, msgRef.sender.name)
			receiverRoleOfMessage.put(msgRef.name, msgRef.receiver.name)
			parametersOfMessage.put(msgRef.name, new HashSet<String>)
			keyParametersOfMessage.put(msgRef.name, new HashSet<String>)
			inParametersOfMessage.put(msgRef.name, new HashSet<String>)
			outParametersOfMessage.put(msgRef.name, new HashSet<String>)
			nilParametersOfMessage.put(msgRef.name, new HashSet<String>)
			for (parameter : msgRef.parameters.referenceParameterList) {
				if (!parametersOfProtocol.contains(parameter.name)) {
					localParametersOfProtocol.add(parameter.name)
				}
				parametersOfMessage.get(msgRef.name).add(parameter.name)
				if (keyParametersOfProtocol.contains(parameter.name)) {
					keyParametersOfMessage.get(msgRef.name).add(parameter.name)
				}
				if (parameter.adornment.equals("in")) {
					inParametersOfMessage.get(msgRef.name).add(parameter.name)
				} else if (parameter.adornment.equals("out")) {
					outParametersOfMessage.get(msgRef.name).add(parameter.name)
				} else if (parameter.adornment.equals("nil")) {
					nilParametersOfMessage.get(msgRef.name).add(parameter.name)
				} else {
					// TODO since adornment is optional, we may reach here, 
					//		though I do not know what should I do with such a 
					//		parameter
				}
			}
		}
		'''
			package «generatedPackage».«protocolName.toFirstLower»;
			
			import java.util.HashMap;
			import java.util.HashSet;
			import java.util.Map;
			import java.util.Set;
			
			import «libraryPackage».protocol.bspl.BSPLProtocolSchema;
			
			public final class «protocolName.toFirstUpper» implements BSPLProtocolSchema {
«««				public static final String «protocolName.toFirstLower» = "«protocolName»";
			
				«FOR role : rolesOfProtocol»
				public static final String «role» = "«role»";
				«ENDFOR»

				«FOR parameter : parametersOfProtocol»
				public static final String «parameter» = "«parameter»";
				«ENDFOR»
				«FOR parameter : localParametersOfProtocol»
				public static final String «parameter» = "«parameter»";
				«ENDFOR»
			
				«FOR msgName : messageNamesOfProtocol»
				public static final String «msgName» = "«msgName»";
				«ENDFOR»
			
				private static final Set<String> rolesOfProtocol;
				private static final Set<String> parametersOfProtocol;
				private static final Set<String> keyParmetersOfProtocol;
				private static final Set<String> inParametersOfProtocol;
				private static final Set<String> outParametersOfProtocol;
				private static final Set<String> nilParametersOfProtocol;
				private static final Set<String> messageNamesOfProtocol;
				private static final Map<String, String> senderRoleOfMessage;
				private static final Map<String, String> receiverRoleOfMessage;
				private static final Map<String, Set<String>> parametersOfMessage;
				private static final Map<String, Set<String>> keyParametersOfMessage;
				private static final Map<String, Set<String>> inParametersOfMessage;
				private static final Map<String, Set<String>> outParametersOfMessage;
				private static final Map<String, Set<String>> nilParametersOfMessage;
			
				static {
					rolesOfProtocol = new HashSet<>();
					parametersOfProtocol = new HashSet<>();
					keyParmetersOfProtocol = new HashSet<>();
					inParametersOfProtocol = new HashSet<>();
					outParametersOfProtocol = new HashSet<>();
					nilParametersOfProtocol = new HashSet<>();
					messageNamesOfProtocol = new HashSet<>();
					senderRoleOfMessage = new HashMap<>();
					receiverRoleOfMessage = new HashMap<>();
					parametersOfMessage = new HashMap<>();
					keyParametersOfMessage = new HashMap<>();
					inParametersOfMessage = new HashMap<>();
					outParametersOfMessage = new HashMap<>();
					nilParametersOfMessage = new HashMap<>();

					«FOR role : rolesOfProtocol»
					rolesOfProtocol.add(«role»);
					«ENDFOR»
			
					«FOR parameter : parametersOfProtocol»
					parametersOfProtocol.add(«parameter»);
					«ENDFOR»

					«FOR parameter : keyParametersOfProtocol»
					keyParmetersOfProtocol.add(«parameter»);
					«ENDFOR»

					«FOR parameter : inParametersOfProtocol»
					inParametersOfProtocol.add(«parameter»);
					«ENDFOR»

					«FOR parameter : outParametersOfProtocol»
					outParametersOfProtocol.add(«parameter»);
					«ENDFOR»

					«FOR parameter : nilParametersOfProtocol»
					nilParametersOfProtocol.add(«parameter»);
					«ENDFOR»

					«FOR messageName : messageNamesOfProtocol»
					messageNamesOfProtocol.add(«messageName»);
					senderRoleOfMessage.put(«messageName», «senderRoleOfMessage.get(messageName)»);
					receiverRoleOfMessage.put(«messageName», «receiverRoleOfMessage.get(messageName)»);
					parametersOfMessage.put(«messageName», new HashSet<>());
					«FOR parameter : parametersOfMessage.get(messageName)»				
					parametersOfMessage.get(«messageName»).add(«parameter»);
					«ENDFOR»
					keyParametersOfMessage.put(«messageName», new HashSet<>());
					«FOR parameter : keyParametersOfMessage.get(messageName)»				
					keyParametersOfMessage.get(«messageName»).add(«parameter»);
					«ENDFOR»
					inParametersOfMessage.put(«messageName», new HashSet<>());
					«FOR parameter : inParametersOfMessage.get(messageName)»				
					inParametersOfMessage.get(«messageName»).add(«parameter»);
					«ENDFOR»
					outParametersOfMessage.put(«messageName», new HashSet<>());
					«FOR parameter : outParametersOfMessage.get(messageName)»				
					outParametersOfMessage.get(«messageName»).add(«parameter»);
					«ENDFOR»
					nilParametersOfMessage.put(«messageName», new HashSet<>());
					«FOR parameter : nilParametersOfMessage.get(messageName)»
					nilParametersOfMessage.get(«messageName»).add(«parameter»);
					«ENDFOR»
					«ENDFOR»
				}
			
				@Override
				public String getProtocolName() {
					return "«protocolName»";
				}
			
				@Override
				public Set<String> getRolesOfProtocol() {
					return new HashSet<>(rolesOfProtocol);	
				}
			
				@Override
				public Set<String> getParametersOfProtocol() {
					return new HashSet<>(parametersOfProtocol);
				}
			
				@Override
				public Set<String> getKeyParametersOfProtocol() {
					return new HashSet<>(keyParmetersOfProtocol);
				}

				@Override
				public Set<String> getInParametersOfProtocol() {
					return new HashSet<>(inParametersOfProtocol);
				}
			
				@Override			
				public Set<String> getOutParametersOfProtocol() {
					return new HashSet<>(outParametersOfProtocol);
				}

				@Override			
				public Set<String> getNilParametersOfProtocol() {
					return new HashSet<>(nilParametersOfProtocol);
				}

				@Override
				public Set<String> getMessageNamesOfProtocol() {
					return new HashSet<>(messageNamesOfProtocol);
				}

				@Override
				public String getSenderRoleOfMessage(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return senderRoleOfMessage.get(messageName);
				}

				@Override
				public String getReceiverRoleOfMessage(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return receiverRoleOfMessage.get(messageName);
				}

				@Override
				public Set<String> getParametersOfMessage(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return new HashSet<>(parametersOfMessage.get(messageName));
				}

				@Override
				public Set<String> getKeyParametersOfMessage(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return new HashSet<>(keyParametersOfMessage.get(messageName));
				}

				@Override
				public Set<String> getInParametersOfMessage(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return new HashSet<>(inParametersOfMessage.get(messageName));
				}

				@Override
				public Set<String> getOutParametersOfMessage(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return new HashSet<>(outParametersOfMessage.get(messageName));
				}

				@Override
				public Set<String> getNilParametersOfMessage(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return new HashSet<>(nilParametersOfMessage.get(messageName));
				}

«««				@Override
«««				public boolean isSenderRoleOfMsg(String role, String messageName) {
«««					if (role == null) {
«««						throw new NullPointerException();
«««					}
«««					if (messageName == null) {
«««						throw new NullPointerException();
«««					}
«««					if (!messageNamesOfProtocol.contains(messageName)) {
«««						throw new IllegalArgumentException();
«««					}
«««					return senderOfMsg.get(messageName).equals(role);
«««				}
«««
«««				@Override
«««				public boolean isReceiverRoleOfMsg(String role, String messageName) {
«««					if (role == null) {
«««						throw new NullPointerException();
«««					}
«««					if (messageName == null) {
«««						throw new NullPointerException();
«««					}
«««					if (!messageNamesOfProtocol.contains(messageName)) {
«««						throw new IllegalArgumentException();
«««					}
«««					return receiverOfMsg.get(messageName).equals(role);
«««				}
«««
				@Override
				public boolean isParameterOfMessage(String parameter, String messageName) {
					if (parameter == null) {
						throw new NullPointerException();
					}
					if (messageName == null) {
						throw new NullPointerException();
					}
					if (!messageNamesOfProtocol.contains(messageName)) {
						throw new IllegalArgumentException();
					}
					return parametersOfMessage.get(messageName).contains(parameter);
				}
			
				@Override
				public boolean isMessageNameOfProtocol(String messageName) {
					if (messageName == null) {
						throw new NullPointerException();
					}
					return messageNamesOfProtocol.contains(messageName);
				}

«««				@Override
«««				public boolean isKeyOfMsg(String parameter, String messageName) {
«««					if (parameter == null) {
«««						throw new NullPointerException();
«««					}
«««					if (messageName == null) {
«««						throw new NullPointerException();
«««					}
«««					if (!messageNamesOfProtocol.contains(messageName)) {
«««						throw new IllegalArgumentException();
«««					}
«««					return keyParamsOfMsg.get(messageName).contains(parameter);
«««				}
«««
«««				@Override
«««				public boolean isInParamOfMsg(String parameter, String messageName) {
«««					if (parameter == null) {
«««						throw new NullPointerException();
«««					}
«««					if (messageName == null) {
«««						throw new NullPointerException();
«««					}
«««					if (!messageNamesOfProtocol.contains(messageName)) {
«««						throw new IllegalArgumentException();
«««					}
«««					return inParamsOfMsg.get(messageName).contains(parameter);
«««				}
«««
«««				@Override
«««				public boolean isOutParamOfMsg(String parameter, String messageName) {
«««					if (parameter == null) {
«««						throw new NullPointerException();
«««					}
«««					if (messageName == null) {
«««						throw new NullPointerException();
«««					}
«««					if (!messageNamesOfProtocol.contains(messageName)) {
«««						throw new IllegalArgumentException();
«««					}
«««					return outParamsOfMsg.get(messageName).contains(parameter);
«««				}
«««
«««				@Override
«««				public boolean isNilParamOfMsg(String parameter, String messageName) {
«««					if (parameter == null) {
«««						throw new NullPointerException();
«««					}
«««					if (messageName == null) {
«««						throw new NullPointerException();
«««					}
«««					if (!messageNamesOfProtocol.contains(messageName)) {
«««						throw new IllegalArgumentException();
«««					}
«««					return nilParamsOfMsg.get(messageName).contains(parameter);
«««				}

				@Override
				public	String getRelationNameForRoleBindings() {
					return "roleBindings";
				}

			}
		'''
	}
	
	def compileAdapter(Resource resource, String protocolName, String roleName) {
		val messagesWhereRoleNameIsSender = new HashSet<MessageReference>()
		val outOnlymessagesWhereRoleNameIsSender  = new HashSet<MessageReference>()
		val messagesWhereRoleNameIsReceiver = new HashSet<MessageReference>()
		for (msgRef : resource.allContents.toIterable.filter(MessageReference)) {
			if (msgRef.sender.name.equals(roleName)) {
				var isOutOnly = true
				for (parameter : msgRef.parameters.referenceParameterList) {
					if (parameter.adornment.equals("in")) {
						isOutOnly = false
					}
				}
				if (isOutOnly) {
					outOnlymessagesWhereRoleNameIsSender.add(msgRef)
				} else {
					messagesWhereRoleNameIsSender.add(msgRef)
				}
			} else {
				if (msgRef.receiver.name.equals(roleName)) {
					messagesWhereRoleNameIsReceiver.add(msgRef)
				} 
			}
		}
		
		
		'''
		package «generatedPackage».«protocolName.toFirstLower».«roleName.toFirstLower»;

		import java.util.HashSet;
		import java.util.Set;
		import java.net.SocketException;
		import java.net.UnknownHostException;

		import «libraryPackage».protocol.bspl.BSPLMessage;
		import «libraryPackage».protocol.bspl.BSPLProtocolAdapter;
		import «libraryPackage».protocol.bspl.BSPLProtocolSchema;
		import «libraryPackage».relational.LocalHistory;
		import «libraryPackage».communication.ip.ImmutableAgentDirectory;
		
		import «generatedPackage».«protocolName.toFirstLower».«protocolName.toFirstUpper»;
		
		public class «roleName.toFirstUpper»Adapter extends BSPLProtocolAdapter {
		
			private final String «roleName.toFirstLower»ID;
		
			public static «roleName.toFirstUpper»Adapter new«roleName.toFirstUpper»Adapter(String «roleName.toFirstLower»ID, BSPLProtocolSchema protocolSchema, LocalHistory localHistory, int port, ImmutableAgentDirectory directory)  throws SocketException {
				if («roleName.toFirstLower»ID.isEmpty()) {
					throw new IllegalArgumentException();
				}
				if (protocolSchema == null || localHistory == null) {
					throw new NullPointerException();
				}
				return new «roleName.toFirstUpper»Adapter(«roleName.toFirstLower»ID, protocolSchema, localHistory, port, directory);
			}
		
			private «roleName.toFirstUpper»Adapter(String «roleName.toFirstLower»ID, BSPLProtocolSchema protocolSchema, LocalHistory localHistory, int port, ImmutableAgentDirectory directory) throws SocketException {
				super(protocolSchema, localHistory, port, directory);
				this.«roleName.toFirstLower»ID = «roleName.toFirstLower»ID;
			}	
		
			@Override
			public String getAgentID() {
				return «roleName.toFirstLower»ID;
			}
		
			@Override
			protected void send(BSPLMessage message) throws UnknownHostException {
				sendMessage(message);
			}
		
			«FOR msgRef : outOnlymessagesWhereRoleNameIsSender»
			public «msgRef.name.toFirstUpper» getNew«msgRef.name.toFirstUpper»(String «msgRef.receiver.name.toFirstLower»ID) {
				BSPLMessage newBSPLMessage = new BSPLMessage();
				newBSPLMessage.setName(«protocolName».«msgRef.name.toFirstLower»);
				newBSPLMessage.setSender(«roleName.toFirstLower»ID);
				newBSPLMessage.setReceiver(«msgRef.receiver.name.toFirstLower»ID);
				return new «msgRef.name.toFirstUpper»(this, newBSPLMessage);
			}

			«ENDFOR»
			«FOR msgRef : messagesWhereRoleNameIsSender»
			public Set<«msgRef.name.toFirstUpper»> getEnabled«msgRef.name.toFirstUpper»() {
				Set<BSPLMessage> enabledMessages = retrieveEnabledMessages(«protocolName».«msgRef.name.toFirstLower»);
				Set<«msgRef.name.toFirstUpper»> enabled«msgRef.name.toFirstUpper»Messages = new HashSet<>();
				for (BSPLMessage enabledMessage : enabledMessages) {
					enabled«msgRef.name.toFirstUpper»Messages.add(new «msgRef.name.toFirstUpper»(this, enabledMessage));
				}
				return enabled«msgRef.name.toFirstUpper»Messages;
			}

			«ENDFOR»
			«FOR msgRef : messagesWhereRoleNameIsReceiver»
			public Set<«msgRef.name.toFirstUpper»> getReceived«msgRef.name.toFirstUpper»() {
				Set<BSPLMessage> receivedMessages = retrieveReceivedMessages(«protocolName».«msgRef.name.toFirstLower»);
				Set<«msgRef.name.toFirstUpper»> received«msgRef.name.toFirstUpper»Messages = new HashSet<>();
				for (BSPLMessage receivedMessage : receivedMessages) {
					received«msgRef.name.toFirstUpper»Messages.add(new «msgRef.name.toFirstUpper»(receivedMessage));
				}
				return received«msgRef.name.toFirstUpper»Messages;
			}

			«ENDFOR»		
		}
		'''
	}
	
	def compileAsSender(MessageReference msgRef, String protocolName, String roleName) {
		var inList = new LinkedList<String>()
		var outAndNilList = new LinkedList<String>()
		for (parameter : msgRef.parameters.referenceParameterList) {
			if (parameter.adornment.equals('in')) { 
				inList.add(parameter.name)
			} else {
				outAndNilList.add(parameter.name)
			} 
			// TODO can we have unadorned parameters in messages
		}
		
		'''
			package «generatedPackage».«protocolName.toFirstLower».«msgRef.sender.name.toFirstLower»;
			
			import java.net.UnknownHostException;
			
			import «generatedPackage».«protocolName.toFirstLower».«protocolName.toFirstUpper»;
			import «libraryPackage».protocol.bspl.BSPLMessage;
			
			public final class «msgRef.name.toFirstUpper» {
				
				private final «roleName.toFirstUpper»Adapter adapter;
				private final BSPLMessage message;
				
				«msgRef.name.toFirstUpper»(«roleName.toFirstUpper»Adapter adapter, BSPLMessage message) {
					this.adapter = adapter;
					this.message = message;
				}
				
				«FOR parameter : inList»
				public String get«parameter.toFirstUpper»() {
					return message.getValueOfParameter(«protocolName».«parameter»);
				}
				
				«ENDFOR»
				public void send(«FOR parameterName : outAndNilList SEPARATOR ', '»String «parameterName»«ENDFOR») throws UnknownHostException {
					«FOR parameter : outAndNilList»	
					message.bindParameterToValue(«protocolName».«parameter», «parameter»);
					«ENDFOR»
					adapter.send(message);
				}
			
				public String getMessageName() {
					return message.getName();
				}
			
				public String getSender() {
					return message.getSender();
				}
			
				public String getReceiver() {
					return message.getReceiver();
				}
			
			}
		'''
	}
	
	def compileAsReceiver(MessageReference msgRef, String protocolName) {
		'''
			package «generatedPackage».«protocolName.toFirstLower».«msgRef.receiver.name.toFirstLower»;
			
			import «generatedPackage».«protocolName.toFirstLower».«protocolName.toFirstUpper»;
			import «libraryPackage».protocol.bspl.BSPLMessage;
			
			public class «msgRef.name.toFirstUpper» {
				
				private final BSPLMessage message;
				
				«msgRef.name.toFirstUpper»(BSPLMessage message) {
					this.message = message;
				}
			
				«FOR parameter : msgRef.parameters.referenceParameterList»
				public String get«parameter.name.toFirstUpper»() {
				    return message.getValueOfParameter(«protocolName».«parameter.name»);
				}

				«ENDFOR»
				public String getMessageName() {
					return message.getName();
				}

				public String getSender() {
					return message.getSender();
				}

				public String getReceiver() {
					return message.getReceiver();
				}
			}
			
		'''
	}
}
